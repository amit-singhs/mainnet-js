// const { Middleware } = require('swagger-express-middleware');
import http from 'http';
import fs from 'fs';
import path from 'path';
import swaggerUI from 'swagger-ui-express';
import jsYaml from 'js-yaml';
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import bodyParser from 'body-parser';
import { OpenApiValidator } from 'express-openapi-validator';
import logger from './logger.js';
import timeout from 'connect-timeout';
import config from './config.js';
import * as mainnet from 'mainnet-js';
import setupRateLimits from './rateLimits.js';

import makeWsServer from './wsServer.js';
import esmresolver, { handlersCache } from './esmresolver.js';

import { dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));


export default class ExpressServer {
  constructor(port, openApiYaml, docYaml) {
    this.port = port;
    this.app = express();
    this.openApiPath = openApiYaml;
    this.docPath = docYaml;
    try {
      this.schema = jsYaml.safeLoad(fs.readFileSync(openApiYaml));
      this.docSchema = jsYaml.safeLoad(fs.readFileSync(docYaml).toString());
    } catch (e) {
      console.trace(e)
      logger.error('failed to start Express Server', e.message);
    }
    this.setupMiddleware();
  }

  setupMiddleware() {
    // this.setupAllowedMedia();
    this.app.use(cors());
    // const module_path = require.resolve("mainnet-js").replace("main/index.js", "");
    // const latest = fs.readdirSync(module_path).filter(val => val.match(/mainnet-\d+\.\d+.\d+.js$/)).pop();
    // this.app.use('/scripts/mainnet.js', express.static(module_path + latest));
    // const smartBchModulePath = require.resolve("@mainnet-cash/smartbch").replace("main/index.js", "");
    // const smartBchLatest = fs.readdirSync(smartBchModulePath).filter(val => val.match(/smartbch-\d+\.\d+.\d+.js$/)).pop();
    // this.app.use('/scripts/@mainnet-cash/smartbch.js', express.static(smartBchModulePath + smartBchLatest));
    // this.app.use(express.static(__dirname + '/static'));
    this.app.use(bodyParser.json({ limit: '15MB' }));
    this.app.use(express.json());
    this.app.use(timeout(`${config.TIMEOUT}s`));
    this.app.use(express.urlencoded({ extended: false }));
    //this.app.use(cookieParser());
    //Simple test to see that the server is up and responding
    this.app.get("/ready", (req, res) => {
      res.status(200);
      res.json({ "status": "okay" });
    });
    //Send the openapi document *AS GENERATED BY THE GENERATOR*
    this.app.get('/openapi', (req, res) => res.sendFile((path.join(__dirname, "../../swagger/v1/", "api.yml"))));
    //View the openapi document in a visual interface. Should be able to test from this page
    this.app.get('/', (req, res) => {
      res.redirect(301, '/api-docs');
    });

    this.app.use('/api-docs', swaggerUI.serve, swaggerUI.setup(this.docSchema));
    this.app.get("/timeout", (req, res) => {});
    this.app.get('/login-redirect', (req, res) => {
      res.status(200);
      res.json(req.query);
    });
    this.app.get('/oauth2-redirect.html', (req, res) => {
      res.status(200);
      res.json(req.query);
    });
    setupRateLimits(this.app);
  }

  async launch() {
    return new OpenApiValidator({
      apiSpec: this.openApiPath,
      // operationHandlers: path.join(__dirname),
      operationHandlers: {
        basePath: fileURLToPath(new URL('.', import.meta.url)),
        resolver: esmresolver,
      },
      fileUploader: { dest: config.FILE_UPLOAD_PATH },
      validateSecurity: config.API_KEY ? {
        handlers: {
          bearerAuth: (req, scopes, schema) => {
            if (!req.headers.authorization || req.headers.authorization.split(" ")[0].toLowerCase() != "bearer") {
              throw { status: 401, message: 'No bearer authorization header provided' };
            }

            // Splitting on "earer" makes authorization name case insensitive.
            const token = req.headers.authorization.split("earer ")[1];

            if (config.API_KEY !== token) {
              throw { status: 403, message: 'forbidden' };
            }

            return true;
          }
        }
      } : false
    }).install(this.app)
      .catch(e => console.trace(e))
      .then(async () => {
        // eslint-disable-next-line no-unused-vars
        this.app.use((err, req, res, next) => {
          // format errors
          // console.error(err)
          res.status(err.status || 500).json({
            message: err.message || err.error,
            errors: err.errors || '',
          });
        });
        setTimeout(async () => {
          await mainnet.initProviders();
        }, 0);
        const server = this.app.listen(this.port);
        const wsServer = makeWsServer(server);
        server.on('upgrade', (request, socket, head) => {
          wsServer.handleUpgrade(request, socket, head, socket => {
            wsServer.emit('connection', socket, request);
          });
        });
        server.on('close', () => {
          wsServer.close();
        });

        server.app = this.app;
        this.server = server;
        return server;
      })
      .catch(error => {
         console.trace(error)
      });
  }

  async close() {
    await mainnet.disconnectProviders();
    if (this.server !== undefined) {
      await this.server.close();
      // console.log(`Server on port ${this.port} shut down`);
    }
  }
}
